# АиСД-2, 2023, КДЗ-2
## Степанов А, БПИ212

### Запуск проекта 
```zsh
cd <Путь к директории проекта>

python generate.py # генерация входных данных

cmake --build ./build --target all # сборка проекта и создание исполняемого файла

./build/main # запуск исполняемого файла

python make_graphs.py ./data/output # создание графиков
```

### Отчёт

**Фактические сложности выполнения данных алгоритмов:**

**Naive Algorithm -- в худшем случае = O(n * m), в лучшем = O(n)**

**KMP - в худшем случае = O(n + m), в лучшем = O(n)**

*Где n - длина строки, а m - длина подстроки.*

- Из графиков времени выполнения алгоритма от длины искомой  подстроки:

Для [бинарного исходного текста длинной 10000 символов](/data/texts/bin_text_10000.txt):

> Результаты для поиска подстроки без символов и с символами подстановки примерно одинаковы (однако время работы алгоритмов во втором случае в среднем на 10^5 наносекунд больше, чем в первом):
> 
> Изначально время работы обоих КМП алгоритмов незначительно отличается, однако затем оно линейно растёт, с большим коэффициентом для КМП, использующего уточнённые грани. Наивный алгоритм же начинает со значительно более высоким временем работы, которое затем линейно снижается и оказывается несколько меньше такового у КМП с уточнёнными гранями при размере подстроки большей 2800 символов.

Для [бинарного исходного текста длинной 100000 символов](/data/texts/bin_text_100000.txt):

> Результаты для поиска подстроки без символов и с символами подстановки снова примерно одинаковы (однако время работы алгоритмов во втором случае в среднем на 10^6 наносекунд больше, чем в первом):
>
> Изначально время работы обоих КМП алгоритмов незначительно отличается, после чего оно очень сильно колеблется (при небольшом линейном росте у обоих), что сильно затрудняет его сравнение. Однако мне кажется, что для подстроки с символами подстановки КМП, использующий уточнённые грани, работает в среднем лучше, а для подстроки без символов подстановки -- наоборот. Наивный алгоритм начинает со **значительно** более высоким временем работы, которое затем также сильно колеблется и незначительно снижается.

Для [квадричного исходного текста длинной 10000 символов](/data/texts/quad_text_10000.txt):

> В целом ситуация идентична таковой для бинарного текста такой же длины. Разница заключается в том, что начальное время работы для квадричного файла заметно ниже, коэффициенты линейного роста / снижения времени работы алгоритмов напротив -- несколько выше.

Для [квадричного исходного текста длинной 100000 символов](/data/texts/quad_text_100000.txt):

> В целом ситуация идентична таковой для бинарного текста такой же длины. Разница заключается в том, что начальное время работы для квадричного файла заметно ниже, а время работы алгоритмов КМП для подстрок без и с символами подстановки соотносится наоборот.

### - Итого: 

> Полученные графики подтверждают утверждение о времени работы алгоритмов. Так как в полученных измерениях n = const, время работы изменяется линейно относительно m (где n - длина строки, m - длина подстроки) для текстов длинной 10000 символов и изменяется очень рвано для текста длинной 100000 символов (так как в этом случае n много больше m).
> 
>  В среднем КМП алгоритмы работают на порядок быстрее наивного алгоритма (1 * m + n против n * m + 0; где n - const, m - переменная). Однако при поиске подстроки относительно близкой по размеру к самой строке (при том, что строка состоит из в целом случайных символов; т.е. не созданной намеренно для достижения худшего случая) скорость работы наивного алгоритма стремится к лучшему случаю и даже превосходит таковую у КМП.
>
> При этом на сложных данных КМП, использующий уточнённые грани, работает несколько лучше стандартного КМП; хотя на полученных результатах это не совсем заметно -- я думаю, что для более реливантных графиков нужно проверять тексты на более сложных алфавитах. 

### Карта проекта

#### [Основная директория](/)

>  Main файл проекта, запускающий процесс анализа работы всех исходных алгоритмов: [main.cpp](/main.cpp)
> 
>  Python скрипт, генерирующий входные данные: [generate.py](/generate.py)
> 
>  Python скрипт, генерирующий графики на основе полученных выходных данных [make_graphs.py](/make_graphs.py)

#### --> [data](/data/)

> Входные файлы: [texts](/data/texts)
>
> Выходные данные: [output](/data/output/)
>
> Графики, иллюстрирующие выходные данные: [results](/data/results/)
>
>> Графики отсортированы по папкам, соответствующим файлам со входными данными

#### --> [for_time_measure](/for_time_measure/)

> Содержит алгоритмы поиска подстрок без подсчёта производимых операций сравнений строк.

> Алгоритмы для поиска подстрок без символов подстановки: [normal](/for_time_measure/normal/)
>
> Алгоритмы для поиска подстрок с символами подстановки: [with_substitution](/for_time_measure/with_substitution/)

#### --> [for_comp_count_measure](/for_comp_count_measure/)

> Содержит алгоритмы поиска подстрок с подсчётом производимых операций сравнений строк.

> Алгоритмы для поиска подстрок без символов подстановки: [normal](/for_comp_count_measure/normal/)
>
> Алгоритмы для поиска подстрок с символами подстановки: [with_substitution](/for_comp_count_measure/with_substitution/)

#### --> [checker](/checker/)

> Содержит функции предназначенные для измерения времени работу функции / количества сравнений строк, производимых в ней.

#### --> [task_execution](/task_execution/)

> Содержит функции предназначенные для получения времени работы / количества сравнений строк, производимых в ней на некоторых входных данных и записи полученных данных в файл.